####################################
##### Arquivo: db.py
##### Desenvolvedor: Juan F. Voltolini
##### Instituição: FIAP
##### Trabalho: Global Solution - 1º Semestre
##### Grupo: Felipe Sabino da Silva, Juan Felipe Voltolini, Luiz Henrique Ribeiro de Oliveira, Marco Aurélio Eberhardt Assumpção e Paulo Henrique Senise
####################################

import oracledb
import yaml
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass
from typing import List, Optional
from ..utils.logging import get_logger

logger = get_logger(__name__)

@dataclass
class Reading:
    """Representa uma leitura de qualidade da água."""
    timestamp: datetime
    ph: float
    turbidity: float
    chloramines: float
    potability: Optional[int] = None
    id: Optional[int] = None

class DatabaseConnection:
    """Gerencia conexão com Oracle Database."""
    
    def __init__(self):
        self.config = self._load_config()
        self.connection = None
        
    def _load_config(self):
        """Carrega configurações do banco de dados."""
        config_path = Path(__file__).parent.parent.parent / "config" / "config.yaml"
        with open(config_path, 'r', encoding='utf-8') as file:
            return yaml.safe_load(file)['database']
    
    def connect(self):
        """Estabelece conexão com o banco de dados."""
        try:
            self.connection = oracledb.connect(
                user=self.config['user'],
                password=self.config['password'],
                dsn=self.config['dsn']
            )
            logger.info("Conectado ao Oracle Database com sucesso")
            return True
        except oracledb.Error as e:
            logger.error(f"Erro ao conectar ao Oracle: {e}")
            return False
    
    def disconnect(self):
        """Fecha conexão com o banco de dados."""
        if self.connection:
            self.connection.close()
            self.connection = None
            logger.info("Conexão com Oracle fechada")
    
    def execute_query(self, query: str, params: dict = None):
        """Executa uma query SELECT."""
        if not self.connection:
            if not self.connect():
                return None
                
        try:
            cursor = self.connection.cursor()
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            results = cursor.fetchall()
            cursor.close()
            return results
        except oracledb.Error as e:
            logger.error(f"Erro ao executar query: {e}")
            return None
    
    def execute_command(self, command: str, params: dict = None):
        """Executa um comando INSERT/UPDATE/DELETE."""
        if not self.connection:
            if not self.connect():
                return False
                
        try:
            cursor = self.connection.cursor()
            if params:
                cursor.execute(command, params)
            else:
                cursor.execute(command)
            
            self.connection.commit()
            cursor.close()
            return True
        except oracledb.Error as e:
            logger.error(f"Erro ao executar comando: {e}")
            self.connection.rollback()
            return False

class WaterQualityRepository:
    """Repository para operações de dados de qualidade da água."""
    
    def __init__(self):
        self.db = DatabaseConnection()
        self._create_table_if_not_exists()
    
    def _create_table_if_not_exists(self):
        """Cria a tabela readings se não existir."""
        create_table_sql = """
        CREATE TABLE readings (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            timestamp TIMESTAMP,
            ph FLOAT,
            turbidity FLOAT,
            chloramines FLOAT,
            potability NUMBER(1)
        )
        """
        
        # Tenta criar a tabela, ignora erro se já existir
        if self.db.connect():
            try:
                cursor = self.db.connection.cursor()
                cursor.execute(create_table_sql)
                self.db.connection.commit()
                cursor.close()
                logger.info("Tabela readings criada com sucesso")
            except oracledb.Error as e:
                if e.args[0].code == 955:  # Table already exists
                    logger.info("Tabela readings já existe")
                else:
                    logger.error(f"Erro ao criar tabela: {e}")
            finally:
                self.db.disconnect()
    
    def save_reading(self, reading: Reading) -> bool:
        """Salva uma leitura no banco de dados."""
        insert_sql = """
        INSERT INTO readings (timestamp, ph, turbidity, chloramines, potability)
        VALUES (:timestamp, :ph, :turbidity, :chloramines, :potability)
        """
        
        params = {
            'timestamp': reading.timestamp,
            'ph': reading.ph,
            'turbidity': reading.turbidity,
            'chloramines': reading.chloramines,
            'potability': reading.potability
        }
        
        success = self.db.execute_command(insert_sql, params)
        if success:
            logger.info(f"Leitura salva: pH={reading.ph}, Turbidez={reading.turbidity}")
        else:
            logger.error("Falha ao salvar leitura")
        
        return success
    
    def get_readings(self, limit: int = 100) -> List[Reading]:
        """Recupera leituras do banco de dados."""
        select_sql = """
        SELECT id, timestamp, ph, turbidity, chloramines, potability
        FROM readings
        ORDER BY timestamp DESC
        FETCH FIRST :limit ROWS ONLY
        """
        
        results = self.db.execute_query(select_sql, {'limit': limit})
        if not results:
            return []
        
        readings = []
        for row in results:
            reading = Reading(
                id=row[0],
                timestamp=row[1],
                ph=row[2],
                turbidity=row[3],
                chloramines=row[4],
                potability=row[5]
            )
            readings.append(reading)
        
        return readings
    
    def get_alerts(self) -> List[Reading]:
        """Recupera leituras com potabilidade não potável (0)."""
        select_sql = """
        SELECT id, timestamp, ph, turbidity, chloramines, potability
        FROM readings
        WHERE potability = 0
        ORDER BY timestamp DESC
        FETCH FIRST 50 ROWS ONLY
        """
        
        results = self.db.execute_query(select_sql)
        if not results:
            return []
        
        alerts = []
        for row in results:
            reading = Reading(
                id=row[0],
                timestamp=row[1],
                ph=row[2],
                turbidity=row[3],
                chloramines=row[4],
                potability=row[5]
            )
            alerts.append(reading)
        
        return alerts 